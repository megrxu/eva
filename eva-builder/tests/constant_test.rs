use eva_builder::constant::{Constant, ConstantArr, ConstantMat};

#[cfg(test)]
#[test]
fn parse_const() {
    assert_eq!(
        ConstantArr::from("p2=[8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7]"),
        ConstantArr {
            name: "p2".to_string(),
            value: vec![8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,0,1,2,3,4,5,6,7]
        }
    );
    assert_eq!(
        ConstantMat::from("m1=[1,0,2,0;2,3,4,5;1,0,2,0;2,3,4,5]"),
        ConstantMat {
            name: "m1".to_string(),
            value: vec![
                vec![1, 0, 2, 0],
                vec![2, 3, 4, 5],
                vec![1, 0, 2, 0],
                vec![2, 3, 4, 5]
            ]
        }
    );
    assert_eq!(
        Constant::new("m1=[1,0,2,0;2,3,4,5;1,0,2,0;2,3,4,5]"),
        Constant::Matrix(ConstantMat {
            name: "m1".to_string(),
            value: vec![
                vec![1, 0, 2, 0],
                vec![2, 3, 4, 5],
                vec![1, 0, 2, 0],
                vec![2, 3, 4, 5]
            ]
        })
    );
}

#[test]
fn test_sbox() {
    let sbox: [u8; 16] = [
        0xc, 0x5, 0x6, 0xb, 0x9, 0x0, 0xa, 0xd, 0x3, 0xe, 0xf, 0x8, 0x4, 0x7, 0x1, 0x2,
    ];
    for i in 0..16 {
        assert_eq!(alge_sbox(i as u8), sbox[i]);
    }
}

#[test]
fn test_mc() {
    use eva_crypto::generic::{expand_bits, restore_data};
    let state = vec![
        0x0e, 0x09, 0x0d, 0x0b, 0x0b, 0x0e, 0x09, 0x0d, 0x0d, 0x0b, 0x0e, 0x09, 0x09, 0x0d, 0x0b,
        0x0e,
    ];
    let bits = expand_bits(&state, 0);
    let mut ret = expand_bits(&state, 0);
    let mul: Vec<Vec<u8>> = ConstantMat::from(
        "m1=[1,8,9,16,24;2,9,10,17,25;3,10,11,18,26;0,4,8,11,12,19,27;0,5,8,12,13,20,28;6,13,14,21,29;0,7,8,14,15,22,30;0,8,15,23,31;0,9,16,17,24;1,10,17,18,25;2,11,18,19,26;3,8,12,16,19,20,27;4,8,13,16,20,21,28;5,14,21,22,29;6,8,15,16,22,23,30;7,8,16,23,31;0,8,17,24,25;1,9,18,25,26;2,10,19,26,27;3,11,16,20,24,27,28;4,12,16,21,24,28,29;5,13,22,29,30;6,14,16,23,24,30,31;7,15,16,24,31;0,1,8,16,25;1,2,9,17,26;2,3,10,18,27;0,3,4,11,19,24,28;0,4,5,12,20,24,29;5,6,13,21,30;0,6,7,14,22,24,31;0,7,15,23,24;33,40,41,48,56;34,41,42,49,57;35,42,43,50,58;32,36,40,43,44,51,59;32,37,40,44,45,52,60;38,45,46,53,61;32,39,40,46,47,54,62;32,40,47,55,63;32,41,48,49,56;33,42,49,50,57;34,43,50,51,58;35,40,44,48,51,52,59;36,40,45,48,52,53,60;37,46,53,54,61;38,40,47,48,54,55,62;39,40,48,55,63;32,40,49,56,57;33,41,50,57,58;34,42,51,58,59;35,43,48,52,56,59,60;36,44,48,53,56,60,61;37,45,54,61,62;38,46,48,55,56,62,63;39,47,48,56,63;32,33,40,48,57;33,34,41,49,58;34,35,42,50,59;32,35,36,43,51,56,60;32,36,37,44,52,56,61;37,38,45,53,62;32,38,39,46,54,56,63;32,39,47,55,56;65,72,73,80,88;66,73,74,81,89;67,74,75,82,90;64,68,72,75,76,83,91;64,69,72,76,77,84,92;70,77,78,85,93;64,71,72,78,79,86,94;64,72,79,87,95;64,73,80,81,88;65,74,81,82,89;66,75,82,83,90;67,72,76,80,83,84,91;68,72,77,80,84,85,92;69,78,85,86,93;70,72,79,80,86,87,94;71,72,80,87,95;64,72,81,88,89;65,73,82,89,90;66,74,83,90,91;67,75,80,84,88,91,92;68,76,80,85,88,92,93;69,77,86,93,94;70,78,80,87,88,94,95;71,79,80,88,95;64,65,72,80,89;65,66,73,81,90;66,67,74,82,91;64,67,68,75,83,88,92;64,68,69,76,84,88,93;69,70,77,85,94;64,70,71,78,86,88,95;64,71,79,87,88;97,104,105,112,120;98,105,106,113,121;99,106,107,114,122;96,100,104,107,108,115,123;96,101,104,108,109,116,124;102,109,110,117,125;96,103,104,110,111,118,126;96,104,111,119,127;96,105,112,113,120;97,106,113,114,121;98,107,114,115,122;99,104,108,112,115,116,123;100,104,109,112,116,117,124;101,110,117,118,125;102,104,111,112,118,119,126;103,104,112,119,127;96,104,113,120,121;97,105,114,121,122;98,106,115,122,123;99,107,112,116,120,123,124;100,108,112,117,120,124,125;101,109,118,125,126;102,110,112,119,120,126,127;103,111,112,120,127;96,97,104,112,121;97,98,105,113,122;98,99,106,114,123;96,99,100,107,115,120,124;96,100,101,108,116,120,125;101,102,109,117,126;96,102,103,110,118,120,127;96,103,111,119,120]",
    )
    .value;
    for (i, j) in mul.iter().enumerate() {
        ret[i] = j.iter().fold(false, |x, y| x ^ bits[*y as usize]);
    }
    assert_eq!(
        restore_data(&ret, 0),
        [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    );
}

fn alge_sbox(input: u8) -> u8 {
    use eva_crypto::generic::{expand_bits, restore_data};
    let sbox: Vec<bool> = ConstantArr::from(
        "s=[1,1,0,1,1,0,0,0,1,0,0,0,1,1,1,0,1,1,1,0,0,0,1,1,0,0,1,0,1,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,0,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0]",
    )
    .value
    .into_iter()
    .map(|x| match x {
        0 => false,
        _ => true,
    })
    .collect();
    let bits = expand_bits(&vec![input], 4);
    let mut ret_bits = vec![false; 4];
    // bool's power
    let power = |x: bool, y: bool| match y {
        false => true,
        true => x,
    };
    // Convert the radix 2 index to the permutation index
    let convert_table: [u8; 16] = [
        0b0000, 0b1000, 0b0100, 0b0010, 0b0001, 0b1100, 0b1010, 0b1001, 0b0110, 0b0101, 0b0011,
        0b1110, 0b1101, 0b1011, 0b0111, 0b1111,
    ];

    for i in 0..4 {
        let mut bit = false;
        for j in 0..16 {
            let indices = expand_bits(&vec![convert_table[j]], 4);
            bit ^= (0..4)
                .into_iter()
                .fold(true, |s, t| s & power(bits[t], indices[t]))
                & sbox[(i * 16) as usize + j];
        }
        ret_bits[i] = bit;
    }
    restore_data(&ret_bits, 4)[0]
}
