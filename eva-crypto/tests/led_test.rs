use eva_crypto::led;
use eva_crypto::led::mix_columns_serial;
use eva_crypto::generic::*;

#[cfg(test)]
#[test]
fn led_64() {
    let key: [u8; 16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf];
    let plaintext: [u8; 16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf];
    let ciphertext: [u8; 16] = [
        0xa, 0x0, 0x0, 0x3, 0x5, 0x5, 0x1, 0xe, 0x3, 0x8, 0x9, 0x3, 0xf, 0xc, 0x5, 0x8,
    ];

    let msg = create_u8x4x4(&key.clone());
    println!("{:x?}", mix_columns_serial(&msg));
    println!("{:x?}", 8u8.gmul(&8, 4));

    assert!(false);
    assert_eq!(led::LED::new(&key).encrypt(&plaintext), ciphertext.to_vec());
}

#[test]
fn led_80() {
    let key: [u8; 20] = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0, 1, 2, 3,
    ];
    let plaintext: [u8; 16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf];
    let ciphertext: [u8; 16] = [
        0xd, 0x2, 0x7, 0xd, 0xd, 0x2, 0xb, 0x4, 0x2, 0xd, 0xd, 0xc, 0xf, 0x0, 0x8, 0x3,
    ];
    assert_eq!(led::LED::new(&key).encrypt(&plaintext), ciphertext.to_vec());
}

#[test]
fn led_128() {
    let key: [u8; 32] = [
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
        0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    ];
    let plaintext: [u8; 16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf];
    let ciphertext: [u8; 16] = [
        0xd, 0x6, 0xb, 0x8, 0x2, 0x4, 0x5, 0x8, 0x7, 0xf, 0x0, 0x1, 0x4, 0xf, 0xc, 0x2,
    ];
    assert_eq!(led::LED::new(&key).encrypt(&plaintext), ciphertext.to_vec());
}
